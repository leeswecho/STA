#include "classes.h"
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////
void cRandGen::Init(LONG* pRK, VOID* pCA)
{
	bLocalGen = FALSE;
	if (pRK == NULL)
		{
		GenKeyData();
		bLocalGen = TRUE;
		}
			else
			{
				int lc1, lc2; //local counters
				for (lc1 = 0; lc1 < 394; lc1++)
					RandKeys[lc1] = pRK[lc1];
				bLocalGen = FALSE;
			}

	pCAccess = pCA;

	wIndex1 = 0;
	wIndex2 = 100;
	wIndex3 = 199;
	wIndex4 = 297;






}
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////
void cRandGen::GenKeyData()
{
cClassAccess* pCA = (cClassAccess*)pCAccess;

	int lc1, lc2; //lcoal counters
	//this is simple: allocate, and then fill all entries with random numbers
	for (lc1 = 0; lc1 < 394; lc1++)
	{
		LONGLONG Val;

		QueryPerformanceCounter((LARGE_INTEGER *)&Val);

		RandKeys[lc1] = Val % 65536;//rand() / 4;
	}
		
}
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////
void cRandGen::Exit()
{
	//nothing to do here(storage changed to static array 12.16.2002)

}
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////
unsigned long cRandGen::rand2()
{
unsigned long iRet = RandKeys[wIndex1]*RandKeys[wIndex4] + RandKeys[wIndex2]*RandKeys[wIndex3] + RandKeys[wIndex3]*RandKeys[wIndex2] + RandKeys[wIndex4]*RandKeys[wIndex1];
	
	wIndex1++;
	wIndex2++;
	wIndex3++;
	wIndex4++;

	if (wIndex1 >= 99)
		wIndex1 = 0;
	if (wIndex2 >= 198)
		wIndex2 = 100;
	if (wIndex3 >= 296)
		wIndex3 = 199;
	if (wIndex4 >= 393)
		wIndex4 = 297;

return iRet + 1;
}
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////
void cRandGen::ReloadKeys(LONG* pRK)
{
	//changed to much simpler static array arrangement (12.16.2002)
	int lc1, lc2; //local counters
	
	for (lc1 = 0; lc1 < 394; lc1++)
		RandKeys[lc1] = pRK[lc1];
	
	//reset the indexes
	wIndex1 = 0;
	wIndex2 = 100;
	wIndex3 = 199;
	wIndex4 = 297;

}
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////
void cRandGen::ExportKeys(LONG* pRKReceiveBuffer)
{
	//changed 12.16.2002
	int lc1, lc2; //local counters
	
	for (lc1 = 0; lc1 < 394; lc1++)
		pRKReceiveBuffer[lc1] = RandKeys[lc1];
	
}
//////////**************************************************************************************************************************************///////////////////////
//////////**************************************************************************************************************************************///////////////////////


